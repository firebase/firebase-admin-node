## API Report File for "firebase-admin"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Agent } from 'http';
import { Bucket } from '@google-cloud/storage';
import * as _firestore from '@google-cloud/firestore';
import * as rtdb from '@firebase/database-types';

// @public (undocumented)
export function app(name?: string): app.App;

// @public (undocumented)
export namespace app {
    export interface App {
        // (undocumented)
        auth(): auth.Auth;
        // (undocumented)
        database(url?: string): database.Database;
        delete(): Promise<void>;
        // (undocumented)
        firestore(): firestore.Firestore;
        // (undocumented)
        instanceId(): instanceId.InstanceId;
        // (undocumented)
        machineLearning(): machineLearning.MachineLearning;
        // (undocumented)
        messaging(): messaging.Messaging;
        name: string;
        options: AppOptions;
        // (undocumented)
        projectManagement(): projectManagement.ProjectManagement;
        // (undocumented)
        remoteConfig(): remoteConfig.RemoteConfig;
        // (undocumented)
        securityRules(): securityRules.SecurityRules;
        // (undocumented)
        storage(): storage.Storage;
    }
}

// @public
export interface AppOptions {
    credential?: credential.Credential;
    databaseAuthVariableOverride?: object | null;
    databaseURL?: string;
    httpAgent?: Agent;
    projectId?: string;
    serviceAccountId?: string;
    storageBucket?: string;
}

// @public (undocumented)
export const apps: (app.App | null)[];

// @public
export function auth(app?: app.App): auth.Auth;

// @public (undocumented)
export namespace auth {
    export interface ActionCodeSettings {
        android?: {
            packageName: string;
            installApp?: boolean;
            minimumVersion?: string;
        };
        dynamicLinkDomain?: string;
        handleCodeInApp?: boolean;
        iOS?: {
            bundleId: string;
        };
        url: string;
    }
    // (undocumented)
    export interface Auth extends BaseAuth {
        // (undocumented)
        app: app.App;
        tenantManager(): TenantManager;
    }
    export type AuthFactorType = 'phone';
    export interface AuthProviderConfig {
        displayName?: string;
        enabled: boolean;
        providerId: string;
    }
    export interface AuthProviderConfigFilter {
        maxResults?: number;
        pageToken?: string;
        type: 'saml' | 'oidc';
    }
    // (undocumented)
    export interface BaseAuth {
        createCustomToken(uid: string, developerClaims?: object): Promise<string>;
        createProviderConfig(config: AuthProviderConfig): Promise<AuthProviderConfig>;
        createSessionCookie(idToken: string, sessionCookieOptions: SessionCookieOptions): Promise<string>;
        createUser(properties: CreateRequest): Promise<UserRecord>;
        deleteProviderConfig(providerId: string): Promise<void>;
        deleteUser(uid: string): Promise<void>;
        deleteUsers(uids: string[]): Promise<DeleteUsersResult>;
        generateEmailVerificationLink(email: string, actionCodeSettings?: ActionCodeSettings): Promise<string>;
        generatePasswordResetLink(email: string, actionCodeSettings?: ActionCodeSettings): Promise<string>;
        generateSignInWithEmailLink(email: string, actionCodeSettings: ActionCodeSettings): Promise<string>;
        getProviderConfig(providerId: string): Promise<AuthProviderConfig>;
        getUser(uid: string): Promise<UserRecord>;
        getUserByEmail(email: string): Promise<UserRecord>;
        getUserByPhoneNumber(phoneNumber: string): Promise<UserRecord>;
        getUserByProviderUid(providerId: string, uid: string): Promise<UserRecord>;
        getUsers(identifiers: UserIdentifier[]): Promise<GetUsersResult>;
        importUsers(users: UserImportRecord[], options?: UserImportOptions): Promise<UserImportResult>;
        listProviderConfigs(options: AuthProviderConfigFilter): Promise<ListProviderConfigResults>;
        listUsers(maxResults?: number, pageToken?: string): Promise<ListUsersResult>;
        revokeRefreshTokens(uid: string): Promise<void>;
        setCustomUserClaims(uid: string, customUserClaims: object | null): Promise<void>;
        updateProviderConfig(providerId: string, updatedConfig: UpdateAuthProviderRequest): Promise<AuthProviderConfig>;
        updateUser(uid: string, properties: UpdateRequest): Promise<UserRecord>;
        verifyIdToken(idToken: string, checkRevoked?: boolean): Promise<DecodedIdToken>;
        verifySessionCookie(sessionCookie: string, checkForRevocation?: boolean): Promise<DecodedIdToken>;
    }
    export interface CreateMultiFactorInfoRequest {
        displayName?: string;
        factorId: string;
    }
    export interface CreatePhoneMultiFactorInfoRequest extends CreateMultiFactorInfoRequest {
        phoneNumber: string;
    }
    export interface CreateRequest extends UpdateRequest {
        multiFactor?: MultiFactorCreateSettings;
        uid?: string;
    }
    export type CreateTenantRequest = UpdateTenantRequest;
    export interface DecodedIdToken {
        // (undocumented)
        [key: string]: any;
        aud: string;
        auth_time: number;
        email?: string;
        email_verified?: boolean;
        exp: number;
        firebase: {
            identities: {
                [key: string]: any;
            };
            sign_in_provider: string;
            sign_in_second_factor?: string;
            second_factor_identifier?: string;
            tenant?: string;
            [key: string]: any;
        };
        iat: number;
        iss: string;
        phone_number?: string;
        picture?: string;
        sub: string;
        uid: string;
    }
    export interface DeleteUsersResult {
        errors: FirebaseArrayIndexError[];
        failureCount: number;
        successCount: number;
    }
    export interface EmailIdentifier {
        // (undocumented)
        email: string;
    }
    export interface EmailSignInProviderConfig {
        enabled: boolean;
        passwordRequired?: boolean;
    }
    export interface GetUsersResult {
        notFound: UserIdentifier[];
        users: UserRecord[];
    }
    // (undocumented)
    export type HashAlgorithmType = 'SCRYPT' | 'STANDARD_SCRYPT' | 'HMAC_SHA512' | 'HMAC_SHA256' | 'HMAC_SHA1' | 'HMAC_MD5' | 'MD5' | 'PBKDF_SHA1' | 'BCRYPT' | 'PBKDF2_SHA256' | 'SHA512' | 'SHA256' | 'SHA1';
    export interface ListProviderConfigResults {
        pageToken?: string;
        providerConfigs: AuthProviderConfig[];
    }
    export interface ListTenantsResult {
        pageToken?: string;
        tenants: Tenant[];
    }
    export interface ListUsersResult {
        pageToken?: string;
        users: UserRecord[];
    }
    export interface MultiFactorConfig {
        factorIds?: AuthFactorType[];
        state: MultiFactorConfigState;
    }
    export type MultiFactorConfigState = 'ENABLED' | 'DISABLED';
    export interface MultiFactorCreateSettings {
        enrolledFactors: CreateMultiFactorInfoRequest[];
    }
    export interface MultiFactorInfo {
        displayName?: string;
        enrollmentTime?: string;
        factorId: string;
        toJSON(): object;
        uid: string;
    }
    export interface MultiFactorSettings {
        enrolledFactors: MultiFactorInfo[];
        toJSON(): object;
    }
    export interface MultiFactorUpdateSettings {
        enrolledFactors: UpdateMultiFactorInfoRequest[] | null;
    }
    export interface OIDCAuthProviderConfig extends AuthProviderConfig {
        clientId: string;
        issuer: string;
    }
    export interface OIDCUpdateAuthProviderRequest {
        clientId?: string;
        displayName?: string;
        enabled?: boolean;
        issuer?: string;
    }
    export interface PhoneIdentifier {
        // (undocumented)
        phoneNumber: string;
    }
    export interface PhoneMultiFactorInfo extends MultiFactorInfo {
        phoneNumber: string;
    }
    export interface ProviderIdentifier {
        // (undocumented)
        providerId: string;
        // (undocumented)
        providerUid: string;
    }
    export interface SAMLAuthProviderConfig extends AuthProviderConfig {
        callbackURL?: string;
        idpEntityId: string;
        rpEntityId: string;
        ssoURL: string;
        x509Certificates: string[];
    }
    export interface SAMLUpdateAuthProviderRequest {
        callbackURL?: string;
        displayName?: string;
        enabled?: boolean;
        idpEntityId?: string;
        rpEntityId?: string;
        ssoURL?: string;
        x509Certificates?: string[];
    }
    export interface SessionCookieOptions {
        expiresIn: number;
    }
    export interface Tenant {
        displayName?: string;
        emailSignInConfig?: {
            enabled: boolean;
            passwordRequired?: boolean;
        };
        multiFactorConfig?: MultiFactorConfig;
        tenantId: string;
        testPhoneNumbers?: {
            [phoneNumber: string]: string;
        };
        toJSON(): object;
    }
    export interface TenantAwareAuth extends BaseAuth {
        tenantId: string;
    }
    export interface TenantManager {
        // (undocumented)
        authForTenant(tenantId: string): TenantAwareAuth;
        createTenant(tenantOptions: CreateTenantRequest): Promise<Tenant>;
        deleteTenant(tenantId: string): Promise<void>;
        getTenant(tenantId: string): Promise<Tenant>;
        listTenants(maxResults?: number, pageToken?: string): Promise<ListTenantsResult>;
        updateTenant(tenantId: string, tenantOptions: UpdateTenantRequest): Promise<Tenant>;
    }
    export interface UidIdentifier {
        // (undocumented)
        uid: string;
    }
    // (undocumented)
    export type UpdateAuthProviderRequest = SAMLUpdateAuthProviderRequest | OIDCUpdateAuthProviderRequest;
    export interface UpdateMultiFactorInfoRequest {
        displayName?: string;
        enrollmentTime?: string;
        factorId: string;
        uid?: string;
    }
    export interface UpdatePhoneMultiFactorInfoRequest extends UpdateMultiFactorInfoRequest {
        phoneNumber: string;
    }
    export interface UpdateRequest {
        disabled?: boolean;
        displayName?: string | null;
        email?: string;
        emailVerified?: boolean;
        multiFactor?: MultiFactorUpdateSettings;
        password?: string;
        phoneNumber?: string | null;
        photoURL?: string | null;
    }
    export interface UpdateTenantRequest {
        displayName?: string;
        emailSignInConfig?: EmailSignInProviderConfig;
        multiFactorConfig?: MultiFactorConfig;
        testPhoneNumbers?: {
            [phoneNumber: string]: string;
        } | null;
    }
    export type UserIdentifier = UidIdentifier | EmailIdentifier | PhoneIdentifier | ProviderIdentifier;
    export interface UserImportOptions {
        hash: {
            algorithm: HashAlgorithmType;
            key?: Buffer;
            saltSeparator?: Buffer;
            rounds?: number;
            memoryCost?: number;
            parallelization?: number;
            blockSize?: number;
            derivedKeyLength?: number;
        };
    }
    export interface UserImportRecord {
        customClaims?: {
            [key: string]: any;
        };
        disabled?: boolean;
        displayName?: string;
        email?: string;
        emailVerified?: boolean;
        metadata?: UserMetadataRequest;
        multiFactor?: MultiFactorUpdateSettings;
        passwordHash?: Buffer;
        passwordSalt?: Buffer;
        phoneNumber?: string;
        photoURL?: string;
        providerData?: UserProviderRequest[];
        tenantId?: string;
        uid: string;
    }
    export interface UserImportResult {
        errors: FirebaseArrayIndexError[];
        failureCount: number;
        successCount: number;
    }
    export interface UserInfo {
        displayName: string;
        email: string;
        phoneNumber: string;
        photoURL: string;
        providerId: string;
        toJSON(): object;
        uid: string;
    }
    export interface UserMetadata {
        creationTime: string;
        lastRefreshTime?: string | null;
        lastSignInTime: string;
        toJSON(): object;
    }
    export interface UserMetadataRequest {
        creationTime?: string;
        lastSignInTime?: string;
    }
    export interface UserProviderRequest {
        displayName?: string;
        email?: string;
        phoneNumber?: string;
        photoURL?: string;
        providerId: string;
        uid: string;
    }
    export interface UserRecord {
        customClaims?: {
            [key: string]: any;
        };
        disabled: boolean;
        displayName?: string;
        email?: string;
        emailVerified: boolean;
        metadata: UserMetadata;
        multiFactor?: MultiFactorSettings;
        passwordHash?: string;
        passwordSalt?: string;
        phoneNumber?: string;
        photoURL?: string;
        providerData: UserInfo[];
        tenantId?: string | null;
        toJSON(): object;
        tokensValidAfterTime?: string;
        uid: string;
    }
}

// @public (undocumented)
export namespace credential {
    export function applicationDefault(httpAgent?: Agent): Credential;
    export function cert(serviceAccountPathOrObject: string | ServiceAccount, httpAgent?: Agent): Credential;
    export interface Credential {
        getAccessToken(): Promise<GoogleOAuthAccessToken>;
    }
    export function refreshToken(refreshTokenPathOrObject: string | object, httpAgent?: Agent): Credential;
}

// @public
export function database(app?: app.App): database.Database;

// @public (undocumented)
export namespace database {
    // (undocumented)
    export interface Database extends rtdb.FirebaseDatabase {
        getRules(): Promise<string>;
        getRulesJSON(): Promise<object>;
        setRules(source: string | Buffer | object): Promise<void>;
    }
    import DataSnapshot = rtdb.DataSnapshot;
    import EventType = rtdb.EventType;
    import OnDisconnect = rtdb.OnDisconnect;
    import Query = rtdb.Query;
    import Reference = rtdb.Reference;
    import ThenableReference = rtdb.ThenableReference;
    import enableLogging = rtdb.enableLogging;
    const ServerValue: rtdb.ServerValue;
}

// @public
export interface FirebaseArrayIndexError {
    error: FirebaseError;
    index: number;
}

// @public
export interface FirebaseError {
    code: string;
    message: string;
    stack?: string;
    toJSON(): object;
}

// @public (undocumented)
export function firestore(app?: app.App): _firestore.Firestore;

// @public (undocumented)
export namespace firestore {
    import v1beta1 = _firestore.v1beta1;
    import v1 = _firestore.v1;
    import BulkWriter = _firestore.BulkWriter;
    import BulkWriterOptions = _firestore.BulkWriterOptions;
    import CollectionGroup = _firestore.CollectionGroup;
    import CollectionReference = _firestore.CollectionReference;
    import DocumentChangeType = _firestore.DocumentChangeType;
    import DocumentData = _firestore.DocumentData;
    import DocumentReference = _firestore.DocumentReference;
    import DocumentSnapshot = _firestore.DocumentSnapshot;
    import FieldPath = _firestore.FieldPath;
    import FieldValue = _firestore.FieldValue;
    import Firestore = _firestore.Firestore;
    import FirestoreDataConverter = _firestore.FirestoreDataConverter;
    import GeoPoint = _firestore.GeoPoint;
    import GrpcStatus = _firestore.GrpcStatus;
    import Precondition = _firestore.Precondition;
    import Query = _firestore.Query;
    import QueryDocumentSnapshot = _firestore.QueryDocumentSnapshot;
    import QueryPartition = _firestore.QueryPartition;
    import QuerySnapshot = _firestore.QuerySnapshot;
    import ReadOptions = _firestore.ReadOptions;
    import Settings = _firestore.Settings;
    import Timestamp = _firestore.Timestamp;
    import Transaction = _firestore.Transaction;
    import UpdateData = _firestore.UpdateData;
    import WriteBatch = _firestore.WriteBatch;
    import WriteResult = _firestore.WriteResult;
    import setLogFunction = _firestore.setLogFunction;
}

// @public
export interface GoogleOAuthAccessToken {
    // (undocumented)
    access_token: string;
    // (undocumented)
    expires_in: number;
}

// @public (undocumented)
export function initializeApp(options?: AppOptions, name?: string): app.App;

// @public
export function instanceId(app?: app.App): instanceId.InstanceId;

// @public (undocumented)
export namespace instanceId {
    export interface InstanceId {
        // (undocumented)
        app: app.App;
        deleteInstanceId(instanceId: string): Promise<void>;
    }
}

// @public
export function machineLearning(app?: app.App): machineLearning.MachineLearning;

// @public (undocumented)
export namespace machineLearning {
    // (undocumented)
    export interface AutoMLTfliteModelOptions extends ModelOptionsBase {
        // (undocumented)
        tfliteModel: {
            automlModel: string;
        };
    }
    // (undocumented)
    export interface GcsTfliteModelOptions extends ModelOptionsBase {
        // (undocumented)
        tfliteModel: {
            gcsTfliteUri: string;
        };
    }
    export interface ListModelsOptions {
        filter?: string;
        pageSize?: number;
        pageToken?: string;
    }
    export interface ListModelsResult {
        readonly models: Model[];
        readonly pageToken?: string;
    }
    export interface MachineLearning {
        app: app.App;
        createModel(model: ModelOptions): Promise<Model>;
        deleteModel(modelId: string): Promise<void>;
        getModel(modelId: string): Promise<Model>;
        listModels(options?: ListModelsOptions): Promise<ListModelsResult>;
        publishModel(modelId: string): Promise<Model>;
        unpublishModel(modelId: string): Promise<Model>;
        updateModel(modelId: string, model: ModelOptions): Promise<Model>;
    }
    export interface Model {
        readonly createTime: string;
        readonly displayName: string;
        readonly etag: string;
        readonly locked: boolean;
        readonly modelHash?: string;
        readonly modelId: string;
        readonly published: boolean;
        readonly tags?: string[];
        readonly tfliteModel?: TFLiteModel;
        toJSON(): {
            [key: string]: any;
        };
        readonly updateTime: string;
        readonly validationError?: string;
        waitForUnlocked(maxTimeMillis?: number): Promise<void>;
    }
    // (undocumented)
    export type ModelOptions = ModelOptionsBase | GcsTfliteModelOptions | AutoMLTfliteModelOptions;
    export interface ModelOptionsBase {
        // (undocumented)
        displayName?: string;
        // (undocumented)
        tags?: string[];
    }
    export interface TFLiteModel {
        readonly automlModel?: string;
        readonly gcsTfliteUri?: string;
        readonly sizeBytes: number;
    }
}

// @public
export function messaging(app?: app.App): messaging.Messaging;

// @public (undocumented)
export namespace messaging {
    export interface AndroidConfig {
        collapseKey?: string;
        data?: {
            [key: string]: string;
        };
        fcmOptions?: AndroidFcmOptions;
        notification?: AndroidNotification;
        priority?: ('high' | 'normal');
        restrictedPackageName?: string;
        ttl?: number;
    }
    export interface AndroidFcmOptions {
        analyticsLabel?: string;
    }
    export interface AndroidNotification {
        body?: string;
        bodyLocArgs?: string[];
        bodyLocKey?: string;
        channelId?: string;
        clickAction?: string;
        color?: string;
        defaultLightSettings?: boolean;
        defaultSound?: boolean;
        defaultVibrateTimings?: boolean;
        eventTimestamp?: Date;
        icon?: string;
        imageUrl?: string;
        lightSettings?: LightSettings;
        localOnly?: boolean;
        notificationCount?: number;
        priority?: ('min' | 'low' | 'default' | 'high' | 'max');
        sound?: string;
        sticky?: boolean;
        tag?: string;
        ticker?: string;
        title?: string;
        titleLocArgs?: string[];
        titleLocKey?: string;
        vibrateTimingsMillis?: number[];
        visibility?: ('private' | 'public' | 'secret');
    }
    export interface ApnsConfig {
        fcmOptions?: ApnsFcmOptions;
        headers?: {
            [key: string]: string;
        };
        payload?: ApnsPayload;
    }
    export interface ApnsFcmOptions {
        analyticsLabel?: string;
        imageUrl?: string;
    }
    export interface ApnsPayload {
        // (undocumented)
        [customData: string]: any;
        aps: Aps;
    }
    export interface Aps {
        // (undocumented)
        [customData: string]: any;
        alert?: string | ApsAlert;
        badge?: number;
        category?: string;
        contentAvailable?: boolean;
        mutableContent?: boolean;
        sound?: string | CriticalSound;
        threadId?: string;
    }
    // (undocumented)
    export interface ApsAlert {
        // (undocumented)
        actionLocKey?: string;
        // (undocumented)
        body?: string;
        // (undocumented)
        launchImage?: string;
        // (undocumented)
        locArgs?: string[];
        // (undocumented)
        locKey?: string;
        // (undocumented)
        subtitle?: string;
        // (undocumented)
        subtitleLocArgs?: string[];
        // (undocumented)
        subtitleLocKey?: string;
        // (undocumented)
        title?: string;
        // (undocumented)
        titleLocArgs?: string[];
        // (undocumented)
        titleLocKey?: string;
    }
    // (undocumented)
    export interface BaseMessage {
        // (undocumented)
        android?: AndroidConfig;
        // (undocumented)
        apns?: ApnsConfig;
        // (undocumented)
        data?: {
            [key: string]: string;
        };
        // (undocumented)
        fcmOptions?: FcmOptions;
        // (undocumented)
        notification?: Notification;
        // (undocumented)
        webpush?: WebpushConfig;
    }
    export interface BatchResponse {
        failureCount: number;
        responses: SendResponse[];
        successCount: number;
    }
    // (undocumented)
    export interface ConditionMessage extends BaseMessage {
        // (undocumented)
        condition: string;
    }
    export interface CriticalSound {
        critical?: boolean;
        name: string;
        volume?: number;
    }
    export interface DataMessagePayload {
        // (undocumented)
        [key: string]: string;
    }
    export interface FcmOptions {
        analyticsLabel?: string;
    }
    export interface LightSettings {
        color: string;
        lightOffDurationMillis: number;
        lightOnDurationMillis: number;
    }
    export type Message = TokenMessage | TopicMessage | ConditionMessage;
    // (undocumented)
    export interface Messaging {
        app: app.App;
        send(message: Message, dryRun?: boolean): Promise<string>;
        sendAll(messages: Array<Message>, dryRun?: boolean): Promise<BatchResponse>;
        sendMulticast(message: MulticastMessage, dryRun?: boolean): Promise<BatchResponse>;
        sendToCondition(condition: string, payload: MessagingPayload, options?: MessagingOptions): Promise<MessagingConditionResponse>;
        sendToDevice(registrationToken: string | string[], payload: MessagingPayload, options?: MessagingOptions): Promise<MessagingDevicesResponse>;
        sendToDeviceGroup(notificationKey: string, payload: MessagingPayload, options?: MessagingOptions): Promise<MessagingDeviceGroupResponse>;
        sendToTopic(topic: string, payload: MessagingPayload, options?: MessagingOptions): Promise<MessagingTopicResponse>;
        subscribeToTopic(registrationTokens: string | string[], topic: string): Promise<MessagingTopicManagementResponse>;
        unsubscribeFromTopic(registrationTokens: string | string[], topic: string): Promise<MessagingTopicManagementResponse>;
    }
    export interface MessagingConditionResponse {
        messageId: number;
    }
    export interface MessagingDeviceGroupResponse {
        failedRegistrationTokens: string[];
        failureCount: number;
        successCount: number;
    }
    // (undocumented)
    export interface MessagingDeviceResult {
        canonicalRegistrationToken?: string;
        error?: FirebaseError;
        messageId?: string;
    }
    export interface MessagingDevicesResponse {
        // (undocumented)
        canonicalRegistrationTokenCount: number;
        // (undocumented)
        failureCount: number;
        // (undocumented)
        multicastId: number;
        // (undocumented)
        results: MessagingDeviceResult[];
        // (undocumented)
        successCount: number;
    }
    export interface MessagingOptions {
        // (undocumented)
        [key: string]: any | undefined;
        collapseKey?: string;
        contentAvailable?: boolean;
        dryRun?: boolean;
        mutableContent?: boolean;
        priority?: string;
        restrictedPackageName?: string;
        timeToLive?: number;
    }
    export interface MessagingPayload {
        data?: DataMessagePayload;
        notification?: NotificationMessagePayload;
    }
    export interface MessagingTopicManagementResponse {
        errors: FirebaseArrayIndexError[];
        failureCount: number;
        successCount: number;
    }
    export interface MessagingTopicResponse {
        messageId: number;
    }
    export interface MulticastMessage extends BaseMessage {
        // (undocumented)
        tokens: string[];
    }
    export interface Notification {
        body?: string;
        imageUrl?: string;
        title?: string;
    }
    export interface NotificationMessagePayload {
        // (undocumented)
        [key: string]: string | undefined;
        badge?: string;
        body?: string;
        bodyLocArgs?: string;
        bodyLocKey?: string;
        clickAction?: string;
        color?: string;
        icon?: string;
        sound?: string;
        tag?: string;
        title?: string;
        titleLocArgs?: string;
        titleLocKey?: string;
    }
    export interface SendResponse {
        error?: FirebaseError;
        messageId?: string;
        success: boolean;
    }
    // (undocumented)
    export interface TokenMessage extends BaseMessage {
        // (undocumented)
        token: string;
    }
    // (undocumented)
    export interface TopicMessage extends BaseMessage {
        // (undocumented)
        topic: string;
    }
    export interface WebpushConfig {
        data?: {
            [key: string]: string;
        };
        fcmOptions?: WebpushFcmOptions;
        headers?: {
            [key: string]: string;
        };
        notification?: WebpushNotification;
    }
    export interface WebpushFcmOptions {
        link?: string;
    }
    export interface WebpushNotification {
        // (undocumented)
        [key: string]: any;
        actions?: Array<{
            action: string;
            icon?: string;
            title: string;
        }>;
        badge?: string;
        body?: string;
        data?: any;
        dir?: 'auto' | 'ltr' | 'rtl';
        icon?: string;
        image?: string;
        lang?: string;
        renotify?: boolean;
        requireInteraction?: boolean;
        silent?: boolean;
        tag?: string;
        timestamp?: number;
        title?: string;
        vibrate?: number | number[];
    }
    {};
}

// @public
export function projectManagement(app?: app.App): projectManagement.ProjectManagement;

// @public (undocumented)
export namespace projectManagement {
    export interface AndroidApp {
        addShaCertificate(certificateToAdd: ShaCertificate): Promise<void>;
        // (undocumented)
        appId: string;
        deleteShaCertificate(certificateToRemove: ShaCertificate): Promise<void>;
        getConfig(): Promise<string>;
        getMetadata(): Promise<AndroidAppMetadata>;
        getShaCertificates(): Promise<ShaCertificate[]>;
        setDisplayName(newDisplayName: string): Promise<void>;
    }
    export interface AndroidAppMetadata extends AppMetadata {
        packageName: string;
        // (undocumented)
        platform: AppPlatform.ANDROID;
    }
    export interface AppMetadata {
        appId: string;
        displayName?: string;
        platform: AppPlatform;
        projectId: string;
        resourceName: string;
    }
    export enum AppPlatform {
        ANDROID = "ANDROID",
        IOS = "IOS",
        PLATFORM_UNKNOWN = "PLATFORM_UNKNOWN"
    }
    export interface IosApp {
        // (undocumented)
        appId: string;
        getConfig(): Promise<string>;
        getMetadata(): Promise<IosAppMetadata>;
        setDisplayName(newDisplayName: string): Promise<void>;
    }
    export interface IosAppMetadata extends AppMetadata {
        bundleId: string;
        // (undocumented)
        platform: AppPlatform.IOS;
    }
    export interface ProjectManagement {
        androidApp(appId: string): AndroidApp;
        // (undocumented)
        app: app.App;
        createAndroidApp(packageName: string, displayName?: string): Promise<AndroidApp>;
        createIosApp(bundleId: string, displayName?: string): Promise<IosApp>;
        iosApp(appId: string): IosApp;
        listAndroidApps(): Promise<AndroidApp[]>;
        listAppMetadata(): Promise<AppMetadata[]>;
        listIosApps(): Promise<IosApp[]>;
        setDisplayName(newDisplayName: string): Promise<void>;
        shaCertificate(shaHash: string): ShaCertificate;
    }
    export interface ShaCertificate {
        certType: ('sha1' | 'sha256');
        resourceName?: string;
        shaHash: string;
    }
}

// @public
export function remoteConfig(app?: app.App): remoteConfig.RemoteConfig;

// @public (undocumented)
export namespace remoteConfig {
    export interface ExplicitParameterValue {
        value: string;
    }
    export interface InAppDefaultValue {
        useInAppDefault: boolean;
    }
    export interface ListVersionsOptions {
        endTime?: Date | string;
        endVersionNumber?: string | number;
        pageSize?: number;
        pageToken?: string;
        startTime?: Date | string;
    }
    export interface ListVersionsResult {
        nextPageToken?: string;
        versions: Version[];
    }
    export interface RemoteConfig {
        // (undocumented)
        app: app.App;
        createTemplateFromJSON(json: string): RemoteConfigTemplate;
        getTemplate(): Promise<RemoteConfigTemplate>;
        getTemplateAtVersion(versionNumber: number | string): Promise<RemoteConfigTemplate>;
        listVersions(options?: ListVersionsOptions): Promise<ListVersionsResult>;
        publishTemplate(template: RemoteConfigTemplate, options?: {
            force: boolean;
        }): Promise<RemoteConfigTemplate>;
        rollback(versionNumber: string | number): Promise<RemoteConfigTemplate>;
        validateTemplate(template: RemoteConfigTemplate): Promise<RemoteConfigTemplate>;
    }
    export interface RemoteConfigCondition {
        expression: string;
        name: string;
        tagColor?: TagColor;
    }
    export interface RemoteConfigParameter {
        conditionalValues?: {
            [key: string]: RemoteConfigParameterValue;
        };
        defaultValue?: RemoteConfigParameterValue;
        description?: string;
    }
    export interface RemoteConfigParameterGroup {
        description?: string;
        parameters: {
            [key: string]: RemoteConfigParameter;
        };
    }
    export type RemoteConfigParameterValue = ExplicitParameterValue | InAppDefaultValue;
    export interface RemoteConfigTemplate {
        conditions: RemoteConfigCondition[];
        readonly etag: string;
        parameterGroups: {
            [key: string]: RemoteConfigParameterGroup;
        };
        parameters: {
            [key: string]: RemoteConfigParameter;
        };
        version?: Version;
    }
    export interface RemoteConfigUser {
        email: string;
        imageUrl?: string;
        name?: string;
    }
    export type TagColor = 'BLUE' | 'BROWN' | 'CYAN' | 'DEEP_ORANGE' | 'GREEN' | 'INDIGO' | 'LIME' | 'ORANGE' | 'PINK' | 'PURPLE' | 'TEAL';
    export interface Version {
        description?: string;
        isLegacy?: boolean;
        rollbackSource?: string;
        updateOrigin?: ('REMOTE_CONFIG_UPDATE_ORIGIN_UNSPECIFIED' | 'CONSOLE' | 'REST_API' | 'ADMIN_SDK_NODE');
        updateTime?: string;
        updateType?: ('REMOTE_CONFIG_UPDATE_TYPE_UNSPECIFIED' | 'INCREMENTAL_UPDATE' | 'FORCED_UPDATE' | 'ROLLBACK');
        updateUser?: RemoteConfigUser;
        versionNumber?: string;
    }
}

// @public (undocumented)
export const SDK_VERSION: string;

// @public
export function securityRules(app?: app.App): securityRules.SecurityRules;

// @public (undocumented)
export namespace securityRules {
    export interface Ruleset extends RulesetMetadata {
        // (undocumented)
        readonly source: RulesFile[];
    }
    export interface RulesetMetadata {
        readonly createTime: string;
        readonly name: string;
    }
    export interface RulesetMetadataList {
        readonly nextPageToken?: string;
        readonly rulesets: RulesetMetadata[];
    }
    export interface RulesFile {
        // (undocumented)
        readonly content: string;
        // (undocumented)
        readonly name: string;
    }
    export interface SecurityRules {
        // (undocumented)
        app: app.App;
        createRuleset(file: RulesFile): Promise<Ruleset>;
        createRulesFileFromSource(name: string, source: string | Buffer): RulesFile;
        deleteRuleset(name: string): Promise<void>;
        getFirestoreRuleset(): Promise<Ruleset>;
        getRuleset(name: string): Promise<Ruleset>;
        getStorageRuleset(bucket?: string): Promise<Ruleset>;
        listRulesetMetadata(pageSize?: number, nextPageToken?: string): Promise<RulesetMetadataList>;
        releaseFirestoreRuleset(ruleset: string | RulesetMetadata): Promise<void>;
        releaseFirestoreRulesetFromSource(source: string | Buffer): Promise<Ruleset>;
        releaseStorageRuleset(ruleset: string | RulesetMetadata, bucket?: string): Promise<void>;
        releaseStorageRulesetFromSource(source: string | Buffer, bucket?: string): Promise<Ruleset>;
    }
}

// @public (undocumented)
export interface ServiceAccount {
    // (undocumented)
    clientEmail?: string;
    // (undocumented)
    privateKey?: string;
    // (undocumented)
    projectId?: string;
}

// @public
export function storage(app?: app.App): storage.Storage;

// @public (undocumented)
export namespace storage {
    export interface Storage {
        app: app.App;
        // (undocumented)
        bucket(name?: string): Bucket;
    }
}


// (No @packageDocumentation comment for this package)

```
